<pre>
  BIP: 85
  레이어: 애플리케이션
  제목: BIP32 키체인으로부터 유도한 결정론적 엔트로피
  작성자: Ethan Kosakovsky <ethankosakovsky@protonmail.com>
  코멘트-요약: 아직 코멘트 없음.
  코멘트-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0085
  상태: 초안
  타입: 정보성
  생성일: 2020-03-20
  라이센스: BSD-2-Clause
           OPL
</pre>

==Abstract==

''"하나의 시드 하나로 모든 것을 규정하고,''
''키 하나로 그것들을 찾고,''
''경로 하나로 모든 것을 가져오고''
''그리고 암호학으로 그것들을 묶습니다."''

호환되지 않는 표준이 다양하기 때문에 여러 지갑에서 사용되는 모든 키체인에 대해 하나의 단일(니모닉) 시드 백업을 유지하는 것은 불가능합니다. 여러 지갑에서 시드를 공유하는 것은 보안상의 이유로 바람직하지 않습니다. 여러 개의 시드를 물리적으로 저장하는 것은 필요한 보안 및 중복성에 따라 어렵습니다.

HD 키체인은 본질적으로 초기 엔트로피에서 유도되므로, 본 제안은 지갑이 초기 니모닉 시드 또는 루트 키를 생성하는 데 사용하는 모든 방법에 공급할 수 있는 키체인으로부터 지갑이 엔트로피를 유도하는 방법을 제안합니다.

==Definitions==

본 문서에서 "반드시(MUST)", "반드시 하지 말아야 함(MUST NOT)", "필수(REQUIRED)", "해야 함(SHALL)", "하지 말아야 함(SHALL NOT)", "해야 함(SHOULD)", "하지 말아야 함(SHOULD NOT)", "권장(RECOMMENDED)", "할 수 있음(MAY)" 및 "선택적(OPTIONAL)"이라는 키워드는 RFC 2119에 설명된 대로 해석해야 합니다.

흔히 사용되는 키체인과 관련된 용어는 매우 다양합니다. 예를 들어 `시드`는 여러 가지 다른 의미를 가지고 있습니다. 이 문서에서는 다음과 같은 용어를 정의합니다.

# '''BIP32 루트 키'''는 BIP32에서 키체인의 최상위 루트로 표시되는 루트 확장 개인키입니다.
# '''BIP39 니모닉''' 은 BIP39에서 니모닉을 해싱하기 전에 사용된 엔트로피로부터 계산된 니모닉 구문입니다.
# '''BIP39 시드'''는 BIP39 니모닉 시드를 해싱한 결과입니다.

==Motivation==

대부분의 지갑은 BIP32 루트 키를 사용해 키체인을 유도하는 방법을 정의한 BIP32를 지원합니다. 따라서 BIP32 루트 키만 백업하면 이 키에서 파생된 모든 키를 포괄할 수 있습니다. BIP32는 BIP32 루트 키(또는 일반적으로 BIP32 확장 키)의 인간 친화적인 직렬화가 없기 때문에 종이 백업이나 수동으로 키를 복원할 때 오류가 발생하기 쉽습니다. BIP39는 이 문제를 해결하기 위해 설계되었지만, BIP32 루트 키를 직렬화하는 대신 약간의 엔트로피를 사용하여 '시드 니모닉'으로 인코딩한 다음 해시하여 BIP32 루트 키로 변환할 수 있는 BIP39 시드를 도출해냅니다. BIP39 니모닉을 저장하는 것만으로도 전체 BIP32 키체인을 재구성할 수 있지만, BIP32 루트 키는 다시 BIP39 니모닉으로 되돌릴 수 없습니다.

<blockquote> [https://github.com/MyLifeForB/bips/blob/master/bip-0032_kr.mediawiki#master-key-generation BIP 32(kr)] 에 따르면 생성된 시드 바이트 시퀀스 S를 HMAC-SHA512(Key = "Bitcoin seed", Data = S) 계산에 이용하여 마스터 키(루트 키)를 생성합니다. 따라서 BIP32 루트 키가 다시 BIP39 니모닉으로 되돌아 갈 수 없습니다. (역자 추가) </blockquote>

대부분의 지갑은 BIP39를 구현하므로 초기화 또는 복원 시 사용자는 BIP39 니모닉과 상호 작용해야 합니다. 대부분의 지갑은 BIP32 확장 개인키를 지원하지 않으므로, 각 지갑은 동일한 BIP39 니모닉을 공유하거나 완전히 별도의 BIP39 니모닉을 사용해야 합니다. 두 시나리오 모두 보안상의 이유로 특별히 만족스럽지 않습니다. 예를 들어 스마트폰의 핫월렛, 조인 마켓 서버, 라이트닝 네트워크 노드 등 일부 지갑은 본질적으로 보안이 취약할 수 있습니다. 특히 서로 다른 지리적 위치에서 분할 키 또는 이중화 백업에 의존하는 사용자에게는 여러 개의 시드를 보유하는 것이 바람직하지 않을 수 있습니다. 추가가 필연적으로 어렵고 사용자가 후속 키에 더 게으르게 되어 보안이 손상되거나 키가 분실될 수 있습니다.

다른 표준을 구현하거나 아예 표준이 없는 지갑은 더 복잡한 문제가 있습니다. 비트코인 코어 지갑은 WIF를 ''hdseed''로 사용하지만, 일렉트럼과 같은 다른 지갑은 다른 니모닉 체계를 사용해 BIP32 루트 키를 도출합니다. 모네로와 같은 다른 암호화폐도 완전히 다른 니모닉 체계를 사용합니다.

궁극적으로 모든 니모닉/시드 체계는 니모닉/시드를 유도하기 위해 "초기 엔트로피"로 시작한 다음, 니모닉을 BIP32 키 또는 개인키로 처리합니다. BIP32 자체를 사용하여 "초기 엔트로피"를 유도한 다음 대상 지갑의 특정 애플리케이션 표준에 따라 동일한 니모닉 또는 시드를 다시 생성할 수 있습니다. 대상 애플리케이션 유형에 따라 균일한 유도를 보장하기 위해 BIP44와 유사한 분류를 사용할 수 있습니다.

==Specification==

여기서는 단일 BIP32 마스터 루트 키를 가정합니다. 이 명세에서는 이 키가 어떻게 유도되었는지는 중요하지 않습니다(예: 직접 또는 BIP39와 같은 니모닉 체계를 통해).

자체 지갑이 필요한 각 애플리케이션은 완전한(fully) 경화 유도 경로를 사용하여 BIP32 마스터 루트 키에서 고유한 개인키를 유도합니다. 그 다음 개인 키(k)는 HMAC-SHA512로 처리되며, 여기서 키는 "bip-entropy-from-k"이고 메시지 페이로드는 개인 키 k 입니다: <code>HMAC-SHA512(key="bip-entropy-from-k", msg=k)</code>. 그 결과 512 비트의 엔트로피가 생성됩니다. 각 애플리케이션은 작업에 필요한 비트 수까지만 사용하고 나머지는 잘라내야 합니다.

HMAC-SHA512 기능은 [http://tools.ietf.org/html/rfc4231 RFC 4231]에 명시되어 있습니다.

===Test vectors===

====Test case 1====
INPUT:
* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb
* PATH: m/83696968'/0'/0'

OUTPUT:
* DERIVED KEY=cca20ccb0e9a90feb0912870c3323b24874b0ca3d8018c4b96d0b97c0e82ded0
* DERIVED ENTROPY=efecfbccffea313214232d29e71563d941229afb4338c21f9517c41aaa0d16f00b83d2a09ef747e7a64e8e2bd5a14869e693da66ce94ac2da570ab7ee48618f7

====Test case 2====
INPUT:
* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb
*PATH: m/83696968'/0'/1'

OUTPUT
* DERIVED KEY=503776919131758bb7de7beb6c0ae24894f4ec042c26032890c29359216e21ba
* DERIVED ENTROPY=70c6e3e8ebee8dc4c0dbba66076819bb8c09672527c4277ca8729532ad711872218f826919f6b67218adde99018a6df9095ab2b58d803b5b93ec9802085a690e

==BIP85-DRNG==

BIP85-DRNG-SHAKE256은 결정론적 출력이 필요한 암호학적 기능을 위한 결정론적 난수 발생기입니다. 그러나 해당 기능에 대한 입력이 BIP85의 HMAC 출력으로 제공되는 64바이트 외에 더 많은 경우에 사용됩니다. BIP85-DRNG-SHAKE256은 BIP85을 사용하여 SHA-3 표준의 SHAKE256 스트림을 시드로 사용합니다. 입력은 정확히 64바이트여야 합니다 (BIP85 HMAC 출력으로부터 나온 값입니다).

RSA 키 생성은 64바이트 이상의 무작위 입력이 필요한 함수의 예입니다. 또한 함수가 완료될 때까지 필요한 임의 입력의 양을 미리 계산할 수 없습니다.

    drng_reader = BIP85DRNG.new(bip85_entropy)
    rsa_key = RSA.generate_key(4096, drng_reader.read())

===Test Vectors===
INPUT:
xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb
* MASTER BIP32 ROOT KEY: m/83696968'/0'/0'

OUTPUT
* DERIVED KEY=cca20ccb0e9a90feb0912870c3323b24874b0ca3d8018c4b96d0b97c0e82ded0
* DERIVED ENTROPY=efecfbccffea313214232d29e71563d941229afb4338c21f9517c41aaa0d16f00b83d2a09ef747e7a64e8e2bd5a14869e693da66ce94ac2da570ab7ee48618f7

* DRNG(80 bytes)=b78b1ee6b345eae6836c2d53d33c64cdaf9a696487be81b03e822dc84b3f1cd883d7559e53d175f243e4c349e822a957bbff9224bc5dde9492ef54e8a439f6bc8c7355b87a925a37ee405a7502991111

==Reference Implementation==

* Python 라이브러리 구현체: [https://github.com/ethankosakovsky/bip85]
* JavaScript 라이브러리 구현체: [https://github.com/hoganri/bip85-js]

===Other Implementations===

* JavaScript 라이브러리 구현체: [https://github.com/hoganri/bip85-js]

* 콜드카드(Coldcard) 펌웨어: [https://github.com/Coldcard/firmware/pull/39]

* Ian Coleman의 니모닉 코드 변환기: [https://github.com/iancoleman/bip39] and [https://iancoleman.io/bip39/]

* 에어갭 볼트(AirGap Vault): [https://github.com/airgap-it/airgap-vault/commit/d64332fc2f332be622a1229acb27f621e23774d6]

btc_hd_wallet: [https://github.com/scgbckbone/btc-hd-wallet]

==Applications==

애플리케이션 번호는 엔트로피가 후처리에 사용되는 방식을 정의합니다. 다음은 몇 가지 기본적인 예입니다:

유도 경로는 <code>m/83696968'/{app_no}'/{index}'</code> 형식을 사용하며, 여기서 ''{app_no}'' 는 애플리케이션의 경로이고 ''{index}'' 는 인덱스입니다.

===BIP39===
애플리케이션 번호: 39'

엔트로피의 최하위(least significant) 바이트를 관련 단어 길이에 매핑하는 데 필요한 비트 수가 되도록 잘라냅니다: 12단어의 경우 128비트, 24단어의 경우 256비트.

유도 경로 형식은 다음과 같습니다: <code>m/83696968'/39'/{language}'/{words}'/{index}'</code>

예시: 영어 단어 12개(첫 번째 인덱스)가 있는 BIP39 니모닉의 경로가 <code>m/83696968'/39'/0'/12'/0'</code> 이면 다음 키는 <code>m/83696968'/39'/0'/12'/1'</code> 등이 됩니다.

언어 테이블

{|
!단어 목록
!코드
|-
| 영어
| 0'
|-
| 일본어
| 1'
|-
| 한국어
| 2'
|-
| 스페인어
| 3'
|-
| 중국어 (간체)
| 4'
|-
| 중국어 (번체)
| 5'
|-
| 프랑스어
| 6'
|-
| 이탈리아어
| 7'
|-
| 체코어
| 8'
|}

단어 테이블

{|
!단어
!엔트로피
!코드
|-
| 12 단어
| 128 비트
| 12'
|-
| 18 단어
| 192 비트
| 18'
|-
| 24 단어
| 256 비트
| 24'
|}

====12 English words====
BIP39 영어 12 단어 니모닉 시드

128 비트의 엔트로피를 BIP39에 입력하여 12 단어 니모닉을 유도합니다

INPUT:
* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb
* PATH: m/83696968'/39'/0'/12'/0'

OUTPUT:
* DERIVED ENTROPY=6250b68daf746d12a24d58b4787a714b
* DERIVED BIP39 MNEMONIC=girl mad pet galaxy egg matter matrix prison refuse sense ordinary nose

====18 English words====
BIP39 영어 18 단어 니모닉 시드

196 비트의 엔트로피를 BIP39에 입력하여 18 단어 니모닉을 유도합니다

INPUT:
* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb
* PATH: m/83696968'/39'/0'/18'/0'

OUTPUT:
* DERIVED ENTROPY=938033ed8b12698449d4bbca3c853c66b293ea1b1ce9d9dc
* DERIVED BIP39 MNEMONIC=near account window bike charge season chef number sketch tomorrow excuse sniff circle vital hockey outdoor supply token

====24 English words====
BIP39 영어 24 단어 니모닉 시드

256 비트의 엔트로피를 BIP39에 입력하여 24 단어 니모닉을 유도합니다

INPUT:
* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb
* PATH: m/83696968'/39'/0'/24'/0'

OUTPUT:
* DERIVED ENTROPY=ae131e2312cdc61331542efe0d1077bac5ea803adf24b313a4f0e48e9c51f37f
* DERIVED BIP39 MNEMONIC=puppy ocean match cereal symbol another shed magic wrap hammer bulb intact gadget divorce twin tonight reason outdoor destroy simple truth cigar social volcano

===HD-Seed WIF===
애플리케이션 번호: 2'

256 bits[1]의 엔트로피를 비밀 지수로 사용해 개인키를 유도하고 비트코인 코어 지갑의 hdseed로 사용될 압축 WIF로 인코딩합니다.

경로 형식은 다음과 같습니다: <code>m/83696968'/2'/{index}'</code>

INPUT:
* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb
* PATH: m/83696968'/2'/0'

OUTPUT
* DERIVED ENTROPY=7040bb53104f27367f317558e78a994ada7296c6fde36a364e5baf206e502bb1
* DERIVED WIF=Kzyv4uF39d4Jrw2W7UryTHwZr1zQVNk4dAFyqE6BuMrMh1Za7uhp

===XPRV===
애플리케이션 번호: 32'

64바이트의 HMAC 다이제스트에서 처음 32바이트는 체인 코드이고, 두 번째 32바이트[1]는 BIP32 XPRV 값에 대한 개인키입니다. 자식 번호, 깊이 및 부모 지문(fingerprint)은 0으로 강제 설정됩니다.

경로 형식은 다음과 같습니다: <code>m/83696968'/32'/{index}'</code>

INPUT:
* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb
* PATH: m/83696968'/32'/0'

OUTPUT
* DERIVED ENTROPY=ead0b33988a616cf6a497f1c169d9e92562604e38305ccd3fc96f2252c177682
* DERIVED WIF=xprv9s21ZrQH143K2srSbCSg4m4kLvPMzcWydgmKEnMmoZUurYuBuYG46c6P71UGXMzmriLzCCBvKQWBUv3vPB3m1SATMhp3uEjXHJ42jFg7myX

===HEX===
애플리케이션 번호: 128169'

유도 경로 형식은 다음과 같습니다: <code>m/83696968'/128169'/{num_bytes}'/{index}'</code>

`16 <= num_bytes <= 64`

`num_bytes` 뒤의 엔트로피의 최하위(least significant) 바이트를 잘라냅니다.

INPUT:
* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb
* PATH: m/83696968'/128169'/64'/0'

OUTPUT
* DERIVED ENTROPY=492db4698cf3b73a5a24998aa3e9d7fa96275d85724a91e71aa2d645442f878555d078fd1f1f67e368976f04137b1f7a0d19232136ca50c44614af72b5582a5c

===RSA===

애플리케이션 번호: 828365'

유도 경로 형식은 다음과 같습니다: <code>m/83696968'/828365'/{key_bits}'/{key_index}'</code>

RSA 키 생성기는 입력 RNG 기능으로 BIP85-DRNG를 사용해야 합니다.

===RSA GPG===

Keys allocated for RSA-GPG purposes use the following scheme:

 - Main key <code>m/83696968'/828365'/{key_bits}'/{key_index}'</code>
 - Sub keys:  <code>m/83696968'/828365'/{key_bits}'/{key_index}'/{sub_key}'</code>

    - key_index is the parent key for CERTIFY capability
    - sub_key <code>0'</code> is used as the ENCRYPTION key
    - sub_key <code>1'</code> is used as the AUTHENTICATION key
    - sub_key <code>2'</code> is usually used as SIGNATURE key

Note on timestamps:

The resulting RSA key can be used to create a GPG key where the creation date MUST be fixed to unix Epoch timestamp 1231006505 (the Bitcoin genesis block time <code>'2009-01-03 18:05:05'</code> UTC) because the key fingerprint is affected by the creation date (Epoch timestamp 0 was not chosen because of legacy behavior in GNUPG implementations for older keys). Additionally, when importing sub-keys under a key in GNUPG, the system time must be frozen to the same timestamp before importing (e.g. by use of <code>faketime</code>).

Note on GPG key capabilities on smartcard/hardware devices:

GPG capable smart-cards SHOULD be be loaded as follows: The encryption slot SHOULD be loaded with the ENCRYPTION capable key; the authentication slot SHOULD be loaded with the AUTHENTICATION capable key. The signature capable slot SHOULD be loaded with the SIGNATURE capable key.

However, depending on available slots on the smart-card, and preferred policy, the CERTIFY capable key MAY be flagged with CERTIFY and SIGNATURE capabilities and loaded into the SIGNATURE capable slot (for example where the smart-card has only three slots and the CERTIFY capability is required on the same card). In this case, the SIGNATURE capable sub-key would be disregarded because the CERTIFY capable key serves a dual purpose.

==Backwards Compatibility==

This specification is not backwards compatible with any other existing specification.

This specification relies on BIP32 but is agnostic to how the BIP32 root key is derived. As such, this standard is able to derive wallets with initialization schemes like BIP39 or Electrum wallet style mnemonics.

==Discussion==

The reason for running the derived key through HMAC-SHA512 and truncating the result as necessary is to prevent leakage of the parent tree should the derived key (''k'') be compromized. While the specification requires the use of hardended key derivation which would prevent this, we cannot enforce hardened derivation, so this method ensures the derived entropy is hardened. Also, from a semantic point of view, since the purpose is to derive entropy and not a private key, we are required to transform the child key. This is done out of an abundance of caution, in order to ward off unwanted side effects should ''k'' be used for a dual purpose, including as a nonce ''hash(k)'', where undesirable and unforeseen interactions could occur.

==Acknowledgements==

Many thanks to Peter Gray and Christopher Allen for their input, and to Peter for suggesting extra application use cases.

==References==

BIP32, BIP39

==Footnotes==

[1] There is a very small chance that you'll make an invalid key that is zero or bigger than the order of the curve. If this occurs, software should hard fail (forcing users to iterate to the next index).

From BIP32:
In case parse<sub>256</sub>(I<sub>L</sub>) is 0 or ≥ n, the resulting key is invalid, and one should proceed with the next value for i. (Note: this has probability lower than 1 in 2<sup>127</sup>.)

==Copyright==

This BIP is dual-licensed under the Open Publication License and BSD 2-clause license.
