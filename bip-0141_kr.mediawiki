<pre>
  BIP: 141
  레이어: 컨센서스 (소프트 포크)
  제목: 세그윗 (컨센서스 레이어)
  저자: Eric Lombrozo <elombrozo@gmail.com>
          Johnson Lau <jl2012@xbt.hk>
          Pieter Wuille <pieter.wuille@gmail.com>
  코멘트-요약: No comments yet.
  코멘트-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0141
  상태: Final
  타입: Standards Track
  생성일: 2015-12-21
  라이센스: PD
</pre>

==Abstract==

이 BIP는 트랜잭션 머클 트리와는 별도로 블록에 커밋된 "증인(witness)"이라는 새로운 구조를 정의합니다. 이 구조에는 트랜잭션 유효성을 확인하는 데는 필요하지만 트랜잭션의 영향을 결정하는 데는 필요하지 않은 데이터가 포함되어 있습니다. 특히 스크립트와 서명이 이 새로운 구조로 이동됩니다.

증인은 코인베이스 트랜잭션을 통해 블록의 기존 머클 루트에 중첩된(nested) 트리에 커밋되며, 이는 이 BIP 소프트포크가 호환되도록 하기 위한 것입니다. 향후 하드 포크는 이 트리를 자체 분기에 배치할 수 있습니다.

==Motivation==

트랜잭션의 전체 효과는 출력 소비(지출)와 새로운 출력 생성에 의해 결정됩니다. 다른 트랜잭션 데이터, 특히 서명은 블록체인 상태를 검증하는 데만 필요하며, 블록체인 상태를 결정하는 데는 필요하지 않습니다.

트랜잭션 머클 트리에 커밋된 트랜잭션 구조에서 이러한 데이터를 제거하면 몇 가지 문제가 해결됩니다:

# '''의도하지 않은 가변성(malleability)이 불가능해집니다'''. 서명 데이터는 더 이상 트랜잭션 해시의 일부가 아니므로, 트랜잭션 서명 방식에 대한 변경은 더 이상 트랜잭션 식별과 관련이 없습니다. 트랜잭션 가변성에 대한 해결책으로서, 이는 표준 서명 방식([https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki BIP62])보다 우수합니다:
#* 모든 입력이 서명되어 있는 한(하나 이상의 CHECKSIG 또는 CHECKMULTISIG 연산으로) 모든 유형의 스크립트에 대해 비자발적 트랜잭션 가변성을 방지합니다
#* m-of-n CHECKMULTISIG 스크립트의 경우, 트랜잭션은 m명의 개인 키 보유자의 동의가 있어야만 가변 가능합니다(BIP62의 경우 개인 키 보유자 1명만 동의하는 것과는 대조)
#* 알려지지 않은(Unknown) ECDSA 서명 가변성으로 인한 비자발적인 거래 가변성을 방지합니다
#* 라이트닝 네트워크와 같은 오프체인 프로토콜의 중요한 특징인 거래 상대방 위험 없이 언컨펌된 거래 의존성 체인을 생성할 수 있습니다
# '''서명 데이터 전송은 선택 사항이 됩니다'''. 피어가 단지 트랜잭션의 존재를 확인하는 대신 트랜잭션의 유효성을 확인하려는 경우에만 필요합니다. 이렇게 하면 SPV 증명의 크기가 줄어들고 동일한 대역폭을 사용하여 더 많은 트랜잭션을 다운로드할 수 있으므로 잠재적으로 SPV 클라이언트의 개인 정보 보호가 향상될 수 있습니다.
# 트랜잭션 데이터의 일부를 현재 프로토콜에 알려지지 않은(Unknown) 구조로 이동하여'''소프트 포크를 통해 일부 제약 조건을 우회할 수 있습니다'''. 예를들어:
#* 블록 크기를 계산할 때 증인의 크기를 무시 / 할인하여 블록 크기를 어느 정도 효과적으로 늘릴 수 있습니다
#* 최대 데이터 푸시 크기(520바이트) 또는 시그옵스 제한과 같은 하드 코딩된 상수는 값을 바꾸거나 제거될 수 있습니다
#* 기존 스크립트 시맨틱의 제한 없이 새로운 스크립트 시스템을 도입할 수 있습니다. 예를 들어, 트랜잭션 서명 검증을 위한 새로운 트랜잭션 다이제스트 알고리즘은 [https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki BIP143]에 설명되어 있습니다

==Specification==

=== Transaction ID ===

새로운 데이터 구조 <code>witness</code>가 정의됩니다. 각 트랜잭션에는 2개의 ID가 있습니다.

<code>txid</code>의 정의는 기존 직렬화 형식의 이중 SHA256으로 변경되지 않습니다:
  
  [nVersion][txins][txouts][nLockTime]
  
새로운 <code>wtxid</code>가 정의됩니다: 증인 데이터와 함께 새 직렬화의 이중 SHA256입니다:
  
  [nVersion][marker][flag][txins][txouts][witness][nLockTime]
  
<code>nVersion</code>, <code>txins</code>, <code>txouts</code>, 및 <code>nLockTime</code>의 형식은 기존 직렬화와 동일합니다.

<code>marker</code>는 반드시(MUST) 1바이트 값 0(0x00)이어야 합니다: <code>0x00</code>.

<code>flag</code>는 1바이트의 0이 아닌 값이어야 합니다(MUST). 현재 <code>0x01</code>을 사용해야 합니다(MUST).

<code>witness</code>은 트랜잭션의 모든 증인 필드의 직렬화입니다. 각 txin은 하나의 증인 필드와 연결됩니다.증인 필드는 txin의 스택 항목 수를 나타내는 <code>var_int</code>로 시작합니다. 그 다음에는 스택 항목이 이어지며, 각 항목은 길이를 나타내는 <code>var_int</code> 로 시작합니다. 증인 데이터는 스크립트가 아닙니다(NOT).

비-증인 프로그램(이하 정의됨) txin은 <code>0x00</code>으로 표시되는 빈 증인 필드와 연결되어야 합니다. 모든 txin이 감시 프로그램이 아닌 경우 트랜잭션의 <code>wtxid</code>는 해당 <code>txid</code>와 동일합니다.

=== Commitment structure ===

새로운 블록 규칙은 <code>wtxid</code>에 대한 commitment가 필요합니다. 코인베이스 트랜잭션의 <code>wtxid</code>는 <code>0x0000....0000</code>으로 가정합니다.

<code>witness root hash</code> 는 블록헤더 <code>hashMerkleRoot</code>와 유사한 방식으로 모든 <code>wtxid</code>를 잎으로 사용하여 계산됩니다.

commitment는 코인베이스 트랜잭션의 <code>scriptPubKey</code>에 기록됩니다. 이 commitment는 38 bytes 이상이어야 하며, 첫 6 바이트는 <code>0x6a24aa21a9ed</code>여야 합니다:
  
   1-byte - OP_RETURN (0x6a)
   1-byte - 다음 36 바이트를 푸시하시오 (0x24)
   4-byte - Commitment 헤더 (0xaa21a9ed)
  32-byte - Commitment 해시: Double-SHA256(witness root hash|witness reserved value)
  
  39th byte onwards: 컨센서스 의미가 없는 선택적 데이터
  
그리고 코인베이스의 인풋의 증인은 <code>witness reserved value</code>을 위한 단일 32 바이트 배열로 구성되어야만 합니다.

패턴과 일치하는 <code>scriptPubKey</code>가 둘 이상 있는 경우, 출력 인덱스가 가장 높은 <code>scriptPubKey</code>가 commitment로 간주됩니다..

블록의 모든 트랜잭션에 증인 데이터가 없는 경우, commitment는 선택 사항입니다.

=== Witness program ===

1바이트 푸시 오피코드(0 ~ 16 바이트)에 이어 2~40 바이트 사이의 데이터 푸시로 구성된 <code>scriptPubKey</code> (또는 BIP26/P2SH에 정의된 <code>redeemScript</code>)는 새로운 특별한 의미를 갖습니다. 첫 번째 푸시 값을 "버전 바이트"라고 합니다. 다음에 푸시된 바이트 벡터를 "증인 프로그램"이라고 합니다.

증인 유효성 검사 로직이 트리거되는 경우는 두 가지입니다. 각 경우에 따라 증인 버전 바이트와 프로그램의 위치, scriptSig의 형태가 결정됩니다:
# 정확히 버전 바이트 푸시와 증인 프로그램 푸시인 <code>scriptPubKey</code>에 의해 트리거 되었을 때, scriptSig 는 반드시 비어있어야 하며 그렇지 않으면 유효성 검사가 실패합니다. (''"네이티브 증인 프로그램(native witness program)"'')
# <code>scriptPubKey</code> 가 P2SH 스크립트이고 <code>scriptSig</code>에 푸시된 BIP16 <code>redeemScript</code>가 버전 바이트 푸시와 증인 프로그램 푸시인 스크립트로 트리거 되었을 때, <code>scriptSig</code>는 반드시 BIP16 <code>redeemScript</code>의 푸시여야 하며 그렇지 않으면 유효성 검사가 실패합니다. (''"P2SH 증인 프로그램(P2SH witness program)"'')

버전 바이트가 0이고 증인 프로그램이 20바이트인 경우:
* P2WPKH(pay-to-witness-public-key-hash) 프로그램으로 해석됩니다.
* 증인은 정확히 2개의 항목(각각 520바이트 이하)으로 구성되어야 합니다. 첫 번째는 서명이고 두 번째는 공개 키입니다.
* 공개 키의 HASH160은 20바이트 증인 프로그램과 일치해야 합니다.
* 일반 스크립트 평가 후, 서명은 CHECKSIG 작업을 통해 공개 키에 대해 검증됩니다. 검증 결과 스택에서 단일 TRUE가 나와야 합니다.

버전 바이트가 0이고 증인 프로그램이 32바이트인 경우:
* P2WSH(Pay-to-Witness-Script-Hash) 프로그램으로 해석됩니다.
* 증인은 스크립트에 공급할 입력 스택과 직렬화된 스크립트(<code>witnessScript</code>)로 구성되어야만 합니다.
* 초기 증인 스택에서 <code>witnessScript</code> (≤ 10,000 bytes)가 팝업됩니다(popped off). <code>witnessScript</code>의 SHA256은 32바이트 증인 프로그램과 일치해야만 합니다.
* <code>witnessScript</code>는 역직렬화되고 일만 스크립트 평가 후 나머지 증인 스택(각 스택 항목당 250바이트 이하)으로 실행됩니다.
* 스크립트는 실패해서는 안 되며 스택에 정확히 하나의 TRUE가 발생해야 합니다.

버전 바이트가 0이지만 감시 프로그램이 20바이트도 아니고 32바이트도 아닌 경우 스크립트가 실패해야 합니다.<ref>예를 들어, OP_0 뒤에 40바이트의 0이 아닌 데이터 푸시가 뒤따르는 scriptPubKey는 잘못된 프로그램 크기로 인해 실패합니다. 그러나 OP_0에 이어 41바이트의 0이 아닌 데이터 푸시가 뒤따르는 scriptPubKey는 감시 프로그램으로 간주되지 않으므로 통과합니다.</ref>

버전 바이트가 1~16인 경우, 증인 프로그램 또는 증인 스택에 대한 추가 해석이 발생하지 않으며, 증인 스택에 대한 크기 제한이 없습니다. 이 버전은 향후 확장을 위해 예약되어 있습니다.<ref>이전 버전과의 호환성을 위해 0에서 16까지의 모든 버전 바이트에 대해 감시 프로그램의 <code>CastToBool</code>값이 0이면 스크립트가 실패해야만 합니다. 그러나 이와 같은 해시를 갖는 것은 해시 함수에 대한 성공적인 사전 이미지 공격이며 위험은 무시할 수 있는 수준입니다.</ref>

=== Other consensus critical limits ===

==== Block size ====

블록은 현재 총 크기가 1,000,000바이트(1MB)로 제한되어 있습니다. 이 제한을 다음과 같이 변경합니다:

''Block weight'' is defined as ''Base size'' * 3 + ''Total size''. (rationale<ref>Rationale of using a single composite constraint, instead of two separate limits such as 1MB base data and 3MB witness data: Using two separate limits would make mining and fee estimation nearly impossible. Miners would need to solve a complex non-linear optimization problem to find the set of transactions that maximize fees given both constraints, and wallets would not be able to know what to pay as it depends on which of the two conditions is most constrained by the time miners try to produce blocks with their transactions in. Another problem with such an approach is freeloading. Once a set of transactions hit the base data 1MB constraint, up to 3MB extra data could be added to the witness by just minimally increasing the fee. The marginal cost for extra witness space effectively becomes zero in that case.</ref>)

''Base size'' is the block size in bytes with the original transaction serialization without any witness-related data, as seen by a non-upgraded node.

''Total size'' is the block size in bytes with transactions serialized as described in [[bip-0144.mediawiki|BIP144]], including base data and witness data.

The new rule is ''block weight'' ≤ 4,000,000.

==== Sigops ====

Sigops per block is currently limited to 20,000. We change this restriction as follows:

Sigops in the current pubkey script, signature script, and P2SH check script are counted at 4 times their previous value.
The sigop limit is likewise quadrupled to ≤ 80,000.

Each P2WPKH input is counted as 1 sigop. In addition, opcodes within a P2WSH <code>witnessScript</code> are counted identically as previously within the P2SH <code>redeemScript</code>. That is, CHECKSIG is counted as only 1 sigop. When preceded by OP_1 to OP_16 CHECKMULTISIG is counted as 1 to 16 sigops respectively, otherwise it is counted as 20 sigops. This rule applies to both native witness program and P2SH witness program.

=== Additional definitions ===

The following definitions are not used for consensus limits, but are suggested to provide language consistent with the terminology introduced above.

==== Transaction size calculations ====

''Transaction weight'' is defined as ''Base transaction size'' * 3 + ''Total transaction size'' (ie. the same method as calculating ''Block weight'' from ''Base size'' and ''Total size'').

''Virtual transaction size'' is defined as ''Transaction weight'' / 4 (rounded up to the next integer).

''Base transaction size'' is the size of the transaction serialised with the witness data stripped.

''Total transaction size'' is the transaction size in bytes serialized as described in [[bip-0144.mediawiki|BIP144]], including base data and witness data.

=== New script semantics ===

Despite that the script language for P2WPKH and P2WSH looks very similar to pre-segregated witness script, there are several notable differences. Users MUST NOT assume that a script spendable in pre-segregated witness system would also be spendable as a P2WPKH or P2WSH script. Before large-scale deployment in the production network, developers should test the scripts on testnet with the default relay policy turned on, and with a small amount of money after BIP141 is activated on mainnet.

A major difference at consensus level is described in [https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki BIP143], as a new transaction digest algorithm for signature verification in version 0 witness program.

Three relay and mining policies are also included in the first release of segregated witness at reference implementation version 0.13.1. Softforks based on these policies are likely to be proposed in the near future. To avoid indefinite delay in transaction confirmation and permanent fund loss in a potential softfork, users MUST observe the new semantics carefully:

# Only compressed public keys are accepted in P2WPKH and P2WSH (See [https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki#Restrictions_on_public_key_type BIP143])
# The argument of OP_IF/NOTIF in P2WSH must be minimal<ref>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013014.html</ref>
# Signature(s) must be null vector(s) if an OP_CHECKSIG or OP_CHECKMULTISIG is failed (for both pre-segregated witness script and P2WSH. See [https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki BIP146])

== Examples ==

=== P2WPKH ===

The following example is a version 0 pay-to-witness-public-key-hash (P2WPKH):

    witness:      <signature> <pubkey>
    scriptSig:    (empty)
    scriptPubKey: 0 <20-byte-key-hash>
                  (0x0014{20-byte-key-hash})

The '0' in scriptPubKey indicates the following push is a version 0 witness program. The length of the witness program indicates that it is a P2WPKH type. The witness must consist of exactly 2 items. The HASH160 of the pubkey in witness must match the witness program.

The signature is verified as

    <signature> <pubkey> CHECKSIG

Comparing with a traditional P2PKH output, the P2WPKH equivalent occupies 3 less bytes in the scriptPubKey, and moves the signature and public key from scriptSig to witness.

=== P2WPKH nested in BIP16 P2SH ===

The following example is the same P2WPKH, but nested in a BIP16 P2SH output.

    witness:      <signature> <pubkey>
    scriptSig:    <0 <20-byte-key-hash>>
                  (0x160014{20-byte-key-hash})
    scriptPubKey: HASH160 <20-byte-script-hash> EQUAL
                  (0xA914{20-byte-script-hash}87)

The only item in scriptSig is hashed with HASH160, compared against the 20-byte-script-hash in scriptPubKey, and interpreted as:

    0 <20-byte-key-hash>

The public key and signature are then verified as described in the previous example.

Comparing with the previous example, the scriptPubKey is 1 byte bigger and the scriptSig is 23 bytes bigger. Although a nested witness program is less efficient, its payment address is fully transparent and backward compatible for all Bitcoin reference client since version 0.6.0.

=== P2WSH ===

The following example is an 1-of-2 multi-signature version 0 pay-to-witness-script-hash (P2WSH).

    witness:      0 <signature1> <1 <pubkey1> <pubkey2> 2 CHECKMULTISIG>
    scriptSig:    (empty)
    scriptPubKey: 0 <32-byte-hash>
                  (0x0020{32-byte-hash})

The '0' in scriptPubKey indicates the following push is a version 0 witness program. The length of the witness program indicates that it is a P2WSH type. The last item in the witness (the "witnessScript") is popped off, hashed with SHA256, compared against the 32-byte-hash in scriptPubKey, and deserialized:

    1 <pubkey1> <pubkey2> 2 CHECKMULTISIG

The script is executed with the remaining data from witness:

    0 <signature1> 1 <pubkey1> <pubkey2> 2 CHECKMULTISIG

P2WSH allows maximum script size of 10,000 bytes, as the 520-byte push limit is bypassed.

The scriptPubKey occupies 34 bytes, as opposed to 23 bytes of BIP16 P2SH. The increased size improves security against possible collision attacks, as 2<sup>80</sup> work is not infeasible anymore (By the end of 2015, 2<sup>84</sup> hashes have been calculated in Bitcoin mining since the creation of Bitcoin). The spending script is same as the one for an equivalent BIP16 P2SH output but is moved to witness.

=== P2WSH nested in BIP16 P2SH ===

The following example is the same 1-of-2 multi-signature P2WSH script, but nested in a BIP16 P2SH output.

    witness:      0 <signature1> <1 <pubkey1> <pubkey2> 2 CHECKMULTISIG>
    scriptSig:    <0 <32-byte-hash>>
                  (0x220020{32-byte-hash})
    scriptPubKey: HASH160 <20-byte-hash> EQUAL
                  (0xA914{20-byte-hash}87)

The only item in scriptSig is hashed with HASH160, compared against the 20-byte-hash in scriptPubKey, and interpreted as:

    0 <32-byte-hash>

The P2WSH witnessScript is then executed as described in the previous example.

Comparing with the previous example, the scriptPubKey is 11 bytes smaller (with reduced security) while witness is the same. However, it also requires 35 bytes in scriptSig.

=== Extensible commitment structure ===

The new commitment in coinbase transaction is a hash of the <code>witness root hash</code> and a <code>witness reserved value</code>. The <code>witness reserved value</code> currently has no consensus meaning, but in the future allows new commitment values for future softforks. For example, if a new consensus-critical commitment is required in the future, the commitment in coinbase becomes:

  Double-SHA256(Witness root hash|Hash(new commitment|witness reserved value))

For backward compatibility, the <code>Hash(new commitment|witness reserved value)</code> will go to the coinbase witness, and the <code>witness reserved value</code> will be recorded in another location specified by the future softfork. Any number of new commitment could be added in this way.

Any commitments that are not consensus-critical to Bitcoin, such as merge-mining, MUST NOT use the <code>witness reserved value</code> to preserve the ability to do upgrades of the Bitcoin consensus protocol.

The optional data space following the commitment also leaves room for metadata of future softforks, and MUST NOT be used for other purpose.

=== Trust-free unconfirmed transaction dependency chain ===

Segregated witness fixes the problem of transaction malleability fundamentally, which enables the building of unconfirmed transaction dependency chains in a trust-free manner.

Two parties, Alice and Bob, may agree to send certain amount of Bitcoin to a 2-of-2 multisig output (the "funding transaction"). Without signing the funding transaction, they may create another transaction, time-locked in the future, spending the 2-of-2 multisig output to third account(s) (the "spending transaction"). Alice and Bob will sign the spending transaction and exchange the signatures. After examining the signatures, they will sign and commit the funding transaction to the blockchain. Without further action, the spending transaction will be confirmed after the lock-time and release the funding according to the original contract. It also retains the flexibility of revoking the original contract before the lock-time, by another spending transaction with shorter lock-time, but only with mutual-agreement of both parties.

Such setups are not possible with BIP62 as the malleability fix, since the spending transaction could not be created without both parties first signing the funding transaction. If Alice reveals the funding transaction signature before Bob does, Bob is able to lock up the funding indefinitely without ever signing the spending transaction.

Unconfirmed transaction dependency chain is a fundamental building block of more sophisticated payment networks, such as duplex micropayment channel and the Lightning Network, which have the potential to greatly improve the scalability and efficiency of the Bitcoin system.

== Future extensions ==

=== Compact fraud proof for SPV nodes ===

Bitcoin right now only has two real security models. A user either runs a full-node which validates every block with all rules in the system, or a SPV (Simple Payment Verification) client which only validates the headers as a proof of publication of some transactions. The Bitcoin whitepaper suggested that SPV nodes may accept alerts from full nodes when they detect an invalid block, prompting the SPV node to download the questioned blocks and transactions for validation. This approach, however, could become a DoS attack vector as there is virtually no cost to generate a false alarm. An alarm must come with a compact, yet deterministic fraud proof.

In the current Bitcoin protocol, it is possible to generate compact fraud proof for almost all rules except a few:

# It is not possible to prove a miner has introduced too many Bitcoins in the coinbase transaction outputs without showing the whole block itself and all input transactions.
# It is not possible to prove the violation of any block specific constraints, such as size and sigop limits, without showing the whole block (and all input transactions in the case of sigop limit)
# It is not possible to prove the spending of a non-existing input without showing all transaction IDs in the blockchain way back to the genesis block.

Extra witness data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify:

# Sum trees for transaction fee can be committed making it possible to construct short proofs that the miner does not add excessive fees to the coinbase transaction. Similar for the block size and sigop count limit.
# Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.

These commitments could be included in the extensible commitment structure through a soft fork and will be transparent to nodes that do not understand such new rules.

=== New script system ===

Since a version byte is pushed before a witness program, and programs with unknown versions are always considered as anyone-can-spend script, it is possible to introduce any new script system with a soft fork. The witness as a structure is not restricted by any existing script semantics and constraints, the 520-byte push limit in particular, and therefore allows arbitrarily large scripts and signatures.

Examples of new script system include Schnorr signatures which reduce the size of multisig transactions dramatically, Lamport signature which is quantum computing resistance, and Merklized abstract syntax trees which allow very compact witness for conditional scripts with extreme complexity.

=== Per-input lock-time and relative-lock-time ===

Currently there is only one nLockTime field in a transaction and all inputs must share the same value. [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP68] enables per-input relative-lock-time using the nSequence field, however, with a limited lock-time period and resolution.

With a soft fork, it is possible to introduce a separate witness structure to allow per-input lock-time and relative-lock-time, and a new script system that could sign and manipulate the new data (like [https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki BIP65] and [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP112]).

== Backward compatibility ==

As a soft fork, older software will continue to operate without modification.  Non-upgraded nodes, however, will not see nor validate the witness data and will consider all witness programs as anyone-can-spend scripts (except a few edge cases where the witness programs are equal to 0, which the script must fail). Wallets should always be wary of anyone-can-spend scripts and treat them with suspicion. Non-upgraded nodes are strongly encouraged to upgrade in order to take advantage of the new features.

'''What a non-upgraded wallet can do'''

* Receiving bitcoin from non-upgraded and upgraded wallets
* Sending bitcoin to non-upgraded and upgraded wallets with traditional P2PKH address (without any benefit of segregated witness)
* Sending bitcoin to upgraded wallets using a P2SH address
* Sending bitcoin to upgraded wallets using a native witness program through [https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki BIP70] payment protocol

'''What a non-upgraded wallet cannot do'''

* Validating segregated witness transaction. It assumes such a transaction is always valid

== Deployment ==

This BIP will be deployed by "version bits" BIP9 with the name "segwit" and using bit 1.

For Bitcoin mainnet, the BIP9 starttime will be midnight 15 november 2016 UTC (Epoch timestamp 1479168000) and BIP9 timeout will be midnight 15 november 2017 UTC (Epoch timestamp 1510704000).

For Bitcoin testnet, the BIP9 starttime will be midnight 1 May 2016 UTC (Epoch timestamp 1462060800) and BIP9 timeout will be midnight 1 May 2017 UTC (Epoch timestamp 1493596800).

== Credits ==

Special thanks to Gregory Maxwell for originating many of the ideas in this BIP and Luke-Jr for figuring out how to deploy this as a soft fork.

== Footnotes ==

<references />

== Reference Implementation ==

https://github.com/bitcoin/bitcoin/pull/8149

== References ==

*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for Version 0 Witness Program]]
*[[bip-0144.mediawiki|BIP144 Segregated Witness (Peer Services)]]
*[[bip-0173.mediawiki|BIP173 Base32 address format for native v0-16 witness outputs]]

== Copyright ==

This document is placed in the public domain.
